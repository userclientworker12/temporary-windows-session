name: Temporary Windows RDP Session via Manual ngrok (Debug)

on:
  workflow_dispatch: # Manual trigger

jobs:
  windows_rdp_session:
    name: Start Temporary Windows RDP Session (Max 6 hours)
    runs-on: windows-latest
    timeout-minutes: 360

    steps:
      - name: Check out repository code
        uses: actions/checkout@v4

      - name: Prepare Runner for RDP and Set Fixed Password
        id: prepare_rdp
        shell: pwsh
        run: |
          # --- Set FIXED Password ---
          # WARNING: Hardcoding passwords is a security risk! Consider using GitHub Secrets instead.
          $password = "PASSword!"
          $username = $env:USERNAME # Get the current runner username (e.g., runneradmin)
          Write-Host "Setting fixed password for user '$username'..."
          # Use net user command to set password
          try {
              net user $username $password
              Write-Host "Password set successfully for $username."
          } catch {
              Write-Error "Failed to set password for $username. Error: $_"
              exit 1 # Fail the job if password cannot be set
          }

          # Mask the password in logs (still good practice even if fixed)
          Write-Host "::add-mask::$password"
          # Set outputs for later steps
          echo "rdp_username=$username" >> $env:GITHUB_OUTPUT
          echo "rdp_password=$password" >> $env:GITHUB_OUTPUT
          Write-Host "Fixed RDP password configured for user $username."

          # --- Enable RDP ---
          Write-Host "Enabling Remote Desktop..."
          Set-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Terminal Server' -name "fDenyTSConnections" -value 0 -Force

          # --- Configure Firewall ---
          Write-Host "Configuring Windows Firewall for RDP..."
          Enable-NetFirewallRule -DisplayGroup "Remote Desktop"

          # --- Optional: Verify RDP Service ---
          $rdpService = Get-Service -Name TermService
          Write-Host "Remote Desktop Service (TermService) status: $($rdpService.Status)"
          if ($rdpService.Status -ne 'Running') {
              Write-Host "Attempting to start TermService..."
              Start-Service -Name TermService
              Start-Sleep -Seconds 5 # Give it a moment to start
              $rdpService = Get-Service -Name TermService
              Write-Host "New TermService status: $($rdpService.Status)"
          }
          Write-Host "Runner preparation complete."

      # === Enhanced Ngrok Setup and Debugging ===
      - name: Download, Configure and Start ngrok Manually (Debug)
        id: start_ngrok # Give step an ID
        shell: pwsh
        env:
           NGROK_AUTHTOKEN: ${{ secrets.NGROK_AUTHTOKEN }}
        run: |
          # Check if Authtoken Secret is present
          if (-not $env:NGROK_AUTHTOKEN) {
              Write-Error "NGROK_AUTHTOKEN secret is missing or empty! Please configure it in repository settings."
              exit 1
          } else {
              Write-Host "NGROK_AUTHTOKEN secret is present."
          }

          # Download ngrok
          $ngrokZip = "$env:TEMP\ngrok.zip"
          $ngrokExe = "$env:TEMP\ngrok.exe"
          Write-Host "Downloading ngrok..."
          try {
              Invoke-WebRequest -Uri "https://bin.equinox.io/c/bNyj1mQVY4c/ngrok-v3-stable-windows-amd64.zip" -OutFile $ngrokZip -ErrorAction Stop
          } catch {
              Write-Error "Failed to download ngrok. Network issue? Error: $_"
              exit 1
          }

          Write-Host "Extracting ngrok..."
          try {
              Expand-Archive -Path $ngrokZip -DestinationPath $env:TEMP -Force -ErrorAction Stop
          } catch {
              Write-Error "Failed to extract ngrok archive. Error: $_"
              exit 1
          }

          if (-not (Test-Path $ngrokExe)) {
              Write-Error "ngrok.exe not found after extraction! Check TEMP directory: $env:TEMP"
              exit 1
          }
          Write-Host "ngrok extracted to $ngrokExe"

          # Configure ngrok Authtoken
          Write-Host "Configuring ngrok authtoken..."
          try {
              # Using -ErrorAction Stop to catch configuration errors
              & $ngrokExe config add-authtoken $env:NGROK_AUTHTOKEN --log=stderr --ErrorAction Stop
              Write-Host "ngrok authtoken configured."
          } catch {
               Write-Error "Failed to configure ngrok authtoken. Is the token valid? Error: $_"
               exit 1
          }

          # Start ngrok tunnel for RDP (port 3389) in the background
          Write-Host "Starting ngrok tunnel process for TCP port 3389..."
          try {
              # Start ngrok process. Logging to stderr might show errors if any.
              Start-Process $ngrokExe -ArgumentList "tcp", "3389", "--log=stderr" -NoNewWindow -ErrorAction Stop
              Write-Host "ngrok process requested to start."
          } catch {
               Write-Error "Failed to start ngrok process. Error: $_"
               exit 1
          }

          # Check if the ngrok process is actually running
          Start-Sleep -Seconds 3 # Brief pause before checking
          $ngrokProcess = Get-Process -Name ngrok -ErrorAction SilentlyContinue
          if (-not $ngrokProcess) {
              Write-Error "ngrok process is NOT running after attempting to start! Check previous logs/errors."
              # Try running ngrok directly in foreground to see output (will block further script execution here)
              # Write-Host "Attempting to run ngrok in foreground for diagnostics..."
              # & $ngrokExe tcp 3389 --log=stdout
              exit 1
          } else {
               Write-Host "ngrok process found running (PID: $($ngrokProcess.Id))."
          }


          # Wait for ngrok to establish tunnel and API to become available
          Write-Host "Waiting up to 15 seconds for ngrok tunnel API..."
          Start-Sleep -Seconds 15 # Increased wait time

          # Query the local ngrok API to get the public URL
          Write-Host "Querying ngrok API for tunnel URL (retries up to 6 times)..."
          $maxAttempts = 6
          $attempt = 0
          $ngrokUrl = $null
          while ($attempt -lt $maxAttempts -and -not $ngrokUrl) {
              $attempt++
              Write-Host "API Query Attempt $attempt/$maxAttempts..."
              try {
                  # Increased timeout for the request
                  $tunnels = Invoke-RestMethod -Uri "http://127.0.0.1:4040/api/tunnels" -Method Get -TimeoutSec 10 -ErrorAction Stop
                  $tcpTunnel = $tunnels.tunnels | Where-Object { $_.proto -eq 'tcp' } | Select-Object -First 1
                  if ($tcpTunnel) {
                      $ngrokUrl = $tcpTunnel.public_url
                      Write-Host "Successfully retrieved ngrok URL: $ngrokUrl"
                  } else {
                       Write-Warning "No TCP tunnel found yet in ngrok API response (Attempt $attempt/$maxAttempts)... Will retry."
                       Start-Sleep -Seconds 6 # Wait longer between retries
                  }
              } catch {
                  Write-Warning "Failed to connect to ngrok API or parse response (Attempt $attempt/$maxAttempts). Is ngrok running and connected? Error: $($_.Exception.Message)"
                  Start-Sleep -Seconds 6 # Wait longer between retries
              }
          }

          if (-not $ngrokUrl) {
              Write-Error "CRITICAL: Failed to retrieve ngrok public URL after $maxAttempts attempts."
              Write-Error "Possible causes: Invalid Authtoken, Network block preventing ngrok connection, ngrok internal error."
              Write-Error "Check your NGROK_AUTHTOKEN secret and the ngrok dashboard (https://dashboard.ngrok.com/status/tunnels) for clues."
              exit 1
          }

          # Set the URL as an output for the next step
          echo "ngrok_url=$ngrokUrl" >> $env:GITHUB_OUTPUT
      # === End of Enhanced Ngrok Setup ===

      # Display Connection Info - Uses output from the manual ngrok step
      - name: Display Connection Info and Keep Job Alive
        shell: pwsh
        env:
          RDP_USERNAME: ${{ steps.prepare_rdp.outputs.rdp_username }}
          RDP_PASSWORD: ${{ steps.prepare_rdp.outputs.rdp_password }} # This will now always be "PASSword!"
          NGROK_URL: ${{ steps.start_ngrok.outputs.ngrok_url }} # Get public URL from manual ngrok step
        run: |
          # Check if ngrok URL was successfully obtained by the previous step
          if (-not $env:NGROK_URL) {
              Write-Error "FATAL: ngrok URL was not passed from the previous step. Workflow logic error or ngrok failed."
              exit 1
          }

          Write-Host "-----------------------------------------------------"
          Write-Host "RDP Session Ready (via ngrok Tunnel)"
          Write-Host "-----------------------------------------------------"
          Write-Host "Use Remote Desktop Connection on your local machine:"
          Write-Host "Computer:      $env:NGROK_URL" # Example: tcp://0.tcp.ngrok.io:12345
          Write-Host "Username:      $env:RDP_USERNAME"
          Write-Host "Password:      $env:RDP_PASSWORD  (<- Should be PASSword!)"
          Write-Host "-----------------------------------------------------"
          Write-Host "IMPORTANT NOTES:"
          Write-Host "* The address looks like 'tcp://HOSTNAME:PORT'."
          Write-Host "* In Remote Desktop Connection, enter HOSTNAME:PORT"
          Write-Host "*   (e.g., '2.tcp.ngrok.io:12345') as the 'Computer'."
          Write-Host "* Performance will likely be POOR and LAGGY."
          Write-Host "* This session will automatically end when the job times out (~6 hours) or is cancelled."
          Write-Host "* Password is set to 'PASSword!' - Handle with care!"
          Write-Host "-----------------------------------------------------"

          # Keep the script running
          Write-Host "Keeping job alive... Session active until timeout or cancellation."
          Start-Sleep -Seconds 21000 # ~5 hours 50 minutes

      # Final step, runs when job ends/is cancelled
      - name: Session Ending
        if: always()
        shell: pwsh
        run: |
          Write-Host "RDP session job is ending."
          # Try to kill the ngrok process gracefully (might not always work)
          Write-Host "Attempting to stop ngrok process..."
          Get-Process | Where-Object { $_.ProcessName -eq 'ngrok' } | Stop-Process -Force -ErrorAction SilentlyContinue
          Write-Host "ngrok stop attempted."
