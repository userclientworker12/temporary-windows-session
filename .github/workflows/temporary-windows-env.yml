name: Temporary Windows RDP Session via Manual ngrok

on:
  workflow_dispatch: # Manual trigger

jobs:
  windows_rdp_session:
    name: Start Temporary Windows RDP Session (Max 6 hours)
    runs-on: windows-latest
    timeout-minutes: 360

    steps:
      - name: Check out repository code
        uses: actions/checkout@v4

      - name: Prepare Runner for RDP and Generate Password
        id: prepare_rdp
        shell: pwsh
        run: |
          # --- Generate and Set Password ---
          $password = -join ((65..90) + (97..122) + (48..57) + (33..47) | Get-Random -Count 16 | % {[char]$_})
          $username = $env:USERNAME # Get the current runner username (e.g., runneradmin)
          Write-Host "Setting password for user '$username'..."
          # Use net user command to set password
          $securePassword = ConvertTo-SecureString $password -AsPlainText -Force
          try {
              net user $username $password
              Write-Host "Password set successfully for $username."
          } catch {
              Write-Error "Failed to set password for $username. Error: $_"
              exit 1 # Fail the job if password cannot be set
          }

          # Mask the password in logs
          Write-Host "::add-mask::$password"
          # Set outputs for later steps
          echo "rdp_username=$username" >> $env:GITHUB_OUTPUT
          echo "rdp_password=$password" >> $env:GITHUB_OUTPUT
          Write-Host "Generated temporary RDP password for user $username."

          # --- Enable RDP ---
          Write-Host "Enabling Remote Desktop..."
          Set-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Terminal Server' -name "fDenyTSConnections" -value 0 -Force

          # --- Configure Firewall ---
          Write-Host "Configuring Windows Firewall for RDP..."
          Enable-NetFirewallRule -DisplayGroup "Remote Desktop"

          # Optional: Disable Network Level Authentication (NLA) - Less secure, might help compatibility in weird network setups
          # Uncomment the next line if you face NLA-related connection issues (try without it first!)
          # Set-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp' -name "UserAuthentication" -value 0 -Force
          # Write-Host "NLA Disabled (Less Secure)."


          # Optional: Verify RDP Service is running
          $rdpService = Get-Service -Name TermService
          Write-Host "Remote Desktop Service (TermService) status: $($rdpService.Status)"
          if ($rdpService.Status -ne 'Running') {
              Write-Host "Attempting to start TermService..."
              Start-Service -Name TermService
              Start-Sleep -Seconds 5 # Give it a moment to start
              $rdpService = Get-Service -Name TermService
              Write-Host "New TermService status: $($rdpService.Status)"
          }

          Write-Host "Runner preparation complete."

      # ***** NEW NGROK SETUP *****
      - name: Download, Configure and Start ngrok Manually
        id: start_ngrok # Give step an ID
        shell: pwsh
        env:
           NGROK_AUTHTOKEN: ${{ secrets.NGROK_AUTHTOKEN }}
        run: |
          # Download ngrok
          $ngrokZip = "$env:TEMP\ngrok.zip"
          $ngrokExe = "$env:TEMP\ngrok.exe"
          Write-Host "Downloading ngrok..."
          Invoke-WebRequest -Uri "https://bin.equinox.io/c/bNyj1mQVY4c/ngrok-v3-stable-windows-amd64.zip" -OutFile $ngrokZip
          Write-Host "Extracting ngrok..."
          Expand-Archive -Path $ngrokZip -DestinationPath $env:TEMP -Force
          if (-not (Test-Path $ngrokExe)) {
              Write-Error "ngrok.exe not found after extraction!"
              exit 1
          }
          Write-Host "ngrok extracted to $ngrokExe"

          # Configure ngrok Authtoken
          Write-Host "Configuring ngrok authtoken..."
          & $ngrokExe config add-authtoken $env:NGROK_AUTHTOKEN --log=stderr

          # Start ngrok tunnel for RDP (port 3389) in the background
          Write-Host "Starting ngrok tunnel for TCP port 3389..."
          # Start ngrok process. Logging to stderr might show errors if any.
          Start-Process $ngrokExe -ArgumentList "tcp", "3389", "--log=stderr" -NoNewWindow

          # Wait for ngrok to establish tunnel and API to become available
          Write-Host "Waiting for ngrok tunnel to initialize..."
          Start-Sleep -Seconds 8 # Give ngrok ~8 seconds

          # Query the local ngrok API to get the public URL
          Write-Host "Querying ngrok API for tunnel URL..."
          $maxAttempts = 5
          $attempt = 0
          $ngrokUrl = $null
          while ($attempt -lt $maxAttempts -and -not $ngrokUrl) {
              $attempt++
              try {
                  $tunnels = Invoke-RestMethod -Uri "http://127.0.0.1:4040/api/tunnels" -Method Get -TimeoutSec 5 -ErrorAction Stop
                  # Find the TCP tunnel (usually the first/only one in this simple setup)
                  $tcpTunnel = $tunnels.tunnels | Where-Object { $_.proto -eq 'tcp' } | Select-Object -First 1
                  if ($tcpTunnel) {
                      $ngrokUrl = $tcpTunnel.public_url
                      Write-Host "Successfully retrieved ngrok URL: $ngrokUrl"
                  } else {
                       Write-Host "No TCP tunnel found yet in ngrok API response (Attempt $attempt/$maxAttempts)..."
                       Start-Sleep -Seconds 5
                  }
              } catch {
                  Write-Warning "Failed to connect to ngrok API or parse response (Attempt $attempt/$maxAttempts). Error: $($_.Exception.Message)"
                  Start-Sleep -Seconds 5
              }
          }

          if (-not $ngrokUrl) {
              Write-Error "Failed to retrieve ngrok public URL after $maxAttempts attempts. Check ngrok logs/status."
              # Consider adding more detailed ngrok log retrieval here if needed
              exit 1
          }

          # Set the URL as an output for the next step
          echo "ngrok_url=$ngrokUrl" >> $env:GITHUB_OUTPUT
      # ***** END OF NEW NGROK SETUP *****

      # Display Connection Info - Uses output from the manual ngrok step
      - name: Display Connection Info and Keep Job Alive
        shell: pwsh
        env:
          RDP_USERNAME: ${{ steps.prepare_rdp.outputs.rdp_username }}
          RDP_PASSWORD: ${{ steps.prepare_rdp.outputs.rdp_password }}
          NGROK_URL: ${{ steps.start_ngrok.outputs.ngrok_url }} # Get public URL from manual ngrok step
        run: |
          # Check if ngrok URL was successfully obtained by the previous step
          if (-not $env:NGROK_URL) {
              Write-Error "FATAL: ngrok URL was not passed from the previous step. Workflow logic error."
              exit 1
          }

          Write-Host "-----------------------------------------------------"
          Write-Host "RDP Session Ready (via ngrok Tunnel)"
          Write-Host "-----------------------------------------------------"
          Write-Host "Use Remote Desktop Connection on your local machine:"
          Write-Host "Computer:      $env:NGROK_URL" # Example: tcp://0.tcp.ngrok.io:12345
          Write-Host "Username:      $env:RDP_USERNAME"
          Write-Host "Password:      $env:RDP_PASSWORD"
          Write-Host "-----------------------------------------------------"
          Write-Host "IMPORTANT NOTES:"
          Write-Host "* The address looks like 'tcp://HOSTNAME:PORT'."
          Write-Host "* In Remote Desktop Connection, enter HOSTNAME:PORT"
          Write-Host "*   (e.g., '2.tcp.ngrok.io:12345') as the 'Computer'."
          Write-Host "* Performance will likely be POOR and LAGGY."
          Write-Host "* This session will automatically end when the job times out (~6 hours) or is cancelled."
          Write-Host "-----------------------------------------------------"

          # Keep the script running
          Write-Host "Keeping job alive... Session active until timeout or cancellation."
          Start-Sleep -Seconds 21000 # ~5 hours 50 minutes

      # Final step, runs when job ends/is cancelled
      - name: Session Ending
        if: always()
        shell: pwsh
        run: |
          Write-Host "RDP session job is ending."
          # Try to kill the ngrok process gracefully (might not always work)
          Get-Process | Where-Object { $_.ProcessName -eq 'ngrok' } | Stop-Process -Force -ErrorAction SilentlyContinue
